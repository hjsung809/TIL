# JPA 퀵 스타트

간단하게 JPA 에 대해 정리해 보겠다.

데이터 베이스 연동에 사용되는 기술은 전통적인 JDBC에서부터, 스프링 DAO, ORM 등 다양하다. 특히 하이버 네이트 같은 ORM은 SQL까지 프레임워크에서 제공해줘서 개발자가 처리해야할 일들을 엄청나게 줄여준다. 이런 ORM들의 표준이 JPA이다.

마이바티스같은 프레임워크는 SQL을 개발자가 직접 XML 파일에 등록해서 사용하고 하이버네이트 같은 ORM 프레임워크에서는 SQL을 생헝하기 떄문에 개발자가 SQL을 직접 작성하지 않아도 된다.



## JPA

하이버 네이트는 자바 표준이 아니고, 자바 표준은 JPA(Java Persistence API)이다. JPA는 JDBC 프로그램에서 JDBC API 와 같은 개념으로 이해하면 된다. JPA는 자바 객체를 컬렉션에 저장하고 관리하는 것과 비슷한 개념이다. 컬렉션에 저장된 객체를 테이블의 로우와 매핑하기 위해서는 JDBC API를 이용해서 실질적인 연동작업이 필요하다. JPA는 자바 애플리케이션과 JDBC 사이에 존재하면서 JDBC의 복잡한 절차를 대신 처리해준다.



## 엔티티 클래스

JPA는 테이블이 없으면 자바 클래스를 기준으로 매핑할 테이블을 자동으로 생성하는데, 테이블과 매핑되는 자바 클래스를 엔티티라고한다. JPA를 사용하기에 앞서 가장 먼저 해야할 일이다. 일반적인 Value Object 클래스처럼 테이블과 동일한 클래스 이름을 사용하고 칼럼과 매핑될 멤버변수를 선언하면된다.

그리고 동시에 영속성 설정파일 'persistence.xml'에 엔티티 등록을 하면된다.(IDE에서 자동으로 해줄 수도 있음) 그리고 @Entity 어노테이션을 클래스에 붙여주면 된다. @Table(name="이름") 형태로 테이블 이름을 따로 설정해줄 수 있다. 멤버 변수에는 @Id 어노테이션으로 테이블의 주 키를 지정할 수 있고, @GeneratedValue 어노테이션으로 키 값이 자동으로 할당되도록 할 수 있다.



## 설정

persistence.xml에 설정을 해야한다. properties 속성으로 jdbc.drive, jdbc.user, jdbc.password, jdbc.url등을 설정한다. 그리고 Jpa 옵션도 설정할 수 있다. hibernate.dialect속성은 JPA에서 어떤 데이터 베이스를 사용할지 지정하는 속성이다. H2 데이터 베이스로 지정하면 H2용 SQL이 만들어진다.



## JPA 데이터 처리

JPA로 실질적인 CRUD 기능을 처리하려면 EntityManager 객체가 필요하다. EntityManager는 EntityManagerFactory로 얻을 수 있다. EntityManagerFactory에서 설정 값을 읽어 EntityManager를 만들어 주면 persist() 메소드를 이용하여 테이블에 접근할 수 있다.

이때 트랜잭션을 시작하지 않았거나 트랜잭션을 정상 종료하지않으면 요청한 작업이 실제 데이터베이스에 반영되지 않는다. try{} catch(){} 문을 이용해서 적절하게 커밋과 롤백을 시켜줘야한다.

이 외에도 디테일한 사항들이 많지만 적당히 넘어가도록 하겠다.



## 영속성 컨텍스트와 엔티티 상태

영속성 컨텍스트(Persisten Context)는 논리적인 개념으로서 EntityManager를 생성할 때 자동으로 만들어진다. 영속성 컨텍스트는 엔티티 객체들을 관리하는 일종의 컨테이너이다. 영속성 컨텍스트에 등록된 엔티티는 EntityManager가 제공하는 메소드에 의해 관리되고 비영속(New), 영속(Managed), 준영속(Detached), 삭제(Removed) 상태로 존재한다.



- 비영속 상태(New): 엔티티 객체를 생성만 했을뿐 엔티티를 영속성 컨텍스트에 저장하지 않은 상태이다.
- 영속 상태(Managed): 영속 상태는 EntityManager를 통해 영속성 컨텍스트에 저장된 상태를 의미한다. 엔티티를 영속상태로 만들기 위해서는 EntityManager의 persist() 메소드를 사용한다. 또한 find() 메서드를 통해서도 엔티티를 영속상태로 만들 수 있다. 조회하려는 엔티티가 영속성 켄텍스트에 있으면 해당 엔티티가 반환되고 없으면 데이터베이스에 데이터를 조회해서 새로운 엔티티 객체를 생성하여 영속성 컨텍스트에 저장하기 때문이다.
- 준영속 상태(DETACHED): 영속성 컨텍스트에 들어간 엔티티가 영속성 컨텍스트에서 벗어난 상태. 값을 수정해도 데이터 베이스에 영향을 주지 못한다. detach(entity)로 특정 엔티티를 준영속상태로 전환하거나 clear(), close() 로 영속성 컨텍스트를 초기화 및 종료하여 관리되는 엔티티들을 모두 삭제할 수 있다.
- 삭제 상태(REMOVED): 엔티티가 영속성 컨텍스트에서 제거되고 테이블에서도 삭제된 상태이다.



## 영속성 컨텍스트와 1차 캐시, SQL  저장소

persist() 메소드를 호출 했다고해 JPA가 곧바로 테이블에 INSERT를 실행하지 않는다. 내부에 1차 캐시라는 것을 사용하기 때문이다. 1차캐시는 일종의 Map 같은 컬렉션으로 Key(@Id로 식별한 값) 과 Value(엔티티 객체)로 엔티티를 관리한다. 1차 캐시에 저장된 엔티티는 EntityTransaction으로 트랜잭션을 종료할때 실제 데이터베이스에 반영된다. 이를 플러시 라고한다.

영속성 켄텍스트는 SQL 저장소라는 것도 가지고 있다. 엔티티를 persist() 메소드로 저장하면 엔티티를 1차 캐시에 등록함과 동시에 INSERT 구문을 생성하여 SQL 저장소에 등록한다. 엔티티 값을 변경하면 UPDATE 관련 SQL 이 SQL 저장소에 저장되었다가 트랜잭션이 종료될때 UPDATE가 처리된다.